"""Output item module for the interpreter.

This module contains the OutputItem class, which represents a single item in the
interpreter output and provides methods for parsing and formatting output items.
"""

import re
from typing import Any, Dict, List, Optional, Tuple


class OutputItem:
    """Represents a single item of raw text output from the interpreter.

    The OutputItem class is responsible for parsing raw text output potentially
    containing structured metadata markers (like Steps, Vars, Triggers, Tool Calls,
    CallStack) generated by the interpreter's LLM. It extracts this metadata
    if present.

    If the text does not contain known metadata markers, the attributes like
    `steps`, `vars`, etc., will remain empty.

    Attributes:
        text (str): The raw text of the output item.
        steps (List[str]): List of step identifiers extracted (e.g., `Step["step_id"]`).
        vars (List[Tuple[str, str]]): List of variable assignments extracted (e.g., `Var["name"] = value`).
        triggers (List[str]): List of trigger identifiers extracted (e.g., `Trigger["trigger_id"]`).
        tool_calls (List[Dict[str, Any]]): List of tool calls extracted (e.g., `ToolName(arg1, kwarg='val')`).
        call_stack (List[str]): List of call stack identifiers extracted (e.g., `CallStack["id1", "id2"]`).
    """

    def __init__(self, text: str):
        """Initialize an output item by parsing the raw text.

        Args:
            text: The raw text of the output item, potentially containing metadata.
        """
        self.text: str = text.strip()
        self.steps: List[str] = []
        self.vars: List[Tuple[str, str]] = []
        self.triggers: List[str] = []
        self.tool_calls: List[Dict[str, Any]] = []
        self.call_stack: List[str] = []

        # Parse the text to extract metadata if present
        self._parse_metadata()

    def _parse_metadata(self) -> None:
        """Parse the raw text to extract structured metadata markers.

        This method uses regular expressions to find and extract steps, variables,
        triggers, tool calls, and call stack information embedded within the text.
        The extracted metadata is stored in the corresponding instance attributes.
        """
        # Extract Step metadata, e.g., `Step["auth_step"]`
        self.steps = re.findall(r'`Step\["([^"]+)"\]`', self.text)

        # Extract Var metadata, e.g., `Var["user_email"] = test@example.com`
        # Note: The value part (.*?) is captured non-greedily.
        self.vars = re.findall(r'`Var\["([^"]+)"\] = (.+?)`', self.text)

        # Extract Trigger metadata, e.g., `Trigger["user_auth_failed"]`
        self.triggers = re.findall(r'`Trigger\["([^"]+)"\]`', self.text)

        # Extract CallStack metadata, e.g. `CallStack["Auth:02:QUE", "Playbook10:04.02:QUE"]`
        # This regex assumes the entire list is within one `CallStack[...]` block.
        # If multiple identifiers are present, they need further splitting if needed elsewhere.
        # Currently, it captures the full inner string "id1", "id2", ...
        # TODO(nic): Consider if splitting the captured string is needed here.
        self.call_stack = re.findall(r'`CallStack\["([^"]+)"\]`', self.text)

        # Extract tool calls (playbook calls) enclosed in backticks.
        # e.g., `MyTool(arg1, arg2, kwarg1="value")`
        tool_call_matches = re.findall(r"`([A-Za-z0-9_]+)\((.*?)\)`", self.text)

        for function_name, args_str in tool_call_matches:
            self.tool_calls.append(
                {
                    "function_name": function_name,
                    "args": self._parse_args(args_str),
                    "kwargs": self._parse_kwargs(args_str),
                }
            )

    def _parse_args(self, args_str: str) -> List[Any]:
        """Parse positional arguments from an argument string.

        This method parses positional arguments from a comma-separated argument string,
        handling nested structures and string literals appropriately.

        Args:
            args_str: The argument string to parse.

        Returns:
            A list of parsed positional arguments.
        """
        if not args_str.strip():
            return []

        args = []
        # Split by commas, but respect strings and nested structures
        parts = self._split_args(args_str)

        for part in parts:
            # Skip keyword arguments
            if "=" in part and not (part.startswith('"') or part.startswith("'")):
                continue
            args.append(self._parse_arg_value(part.strip()))

        return args

    def _parse_kwargs(self, args_str: str) -> Dict[str, Any]:
        """Parse keyword arguments from an argument string.

        This method parses keyword arguments from a comma-separated argument string,
        handling nested structures and string literals appropriately.

        Args:
            args_str: The argument string to parse.

        Returns:
            A dictionary of parsed keyword arguments.
        """
        if not args_str.strip():
            return {}

        kwargs = {}
        # Split by commas, but respect strings and nested structures
        parts = self._split_args(args_str)

        for part in parts:
            # Only process keyword arguments
            if "=" in part and not (part.startswith('"') or part.startswith("'")):
                key, value = part.split("=", 1)
                kwargs[key.strip()] = self._parse_arg_value(value.strip())

        return kwargs

    def _split_args(self, args_str: str) -> List[str]:
        """Split an argument string by commas, respecting strings and nested structures.

        This method manually parses a comma-separated argument string into individual
        argument parts. It handles:
        - Strings enclosed in single (') or double (") quotes.
        - Nested parentheses `()` to correctly identify arguments within function calls
          or tuple-like structures passed as arguments.

        Example:
            Input:  `"hello, world", 123, func(a, b), key="val,ue"`
            Output: [`"hello, world"`, ` 123`, ` func(a, b)`, ` key="val,ue"`]

        Args:
            args_str: The argument string to split.

        Returns:
            A list of argument parts (strings).
        """
        parts = []
        current_part = ""
        in_string = False
        string_char = None  # Stores the type of quote (' or ") that started the string
        paren_level = 0  # Tracks nesting level of parentheses

        for char in args_str:
            # Handle string literals
            if char in ('"', "'") and (not string_char or char == string_char):
                in_string = not in_string
                if in_string:
                    string_char = char
                else:
                    string_char = None  # Exited string
                current_part += char
            # Handle nested parentheses (only outside strings)
            elif char == "(" and not in_string:
                paren_level += 1
                current_part += char
            elif char == ")" and not in_string:
                paren_level -= 1
                current_part += char
            # Split by comma (only outside strings and at the top parenthesis level)
            elif char == "," and not in_string and paren_level == 0:
                parts.append(current_part)
                current_part = ""  # Reset for the next part
            # Append other characters
            else:
                current_part += char

        # Add the last part after the loop finishes
        if current_part:
            parts.append(current_part)

        return parts

    def _parse_arg_value(self, arg_value: str) -> Any:
        """Parse an argument value to the appropriate type.

        This method converts string representations of values to their appropriate Python types,
        handling strings, numbers, booleans, None, and variable references.

        Args:
            arg_value: The string representation of the argument value.

        Returns:
            The parsed value with the appropriate type.
        """
        # Remove quotes for string values
        if (arg_value.startswith('"') and arg_value.endswith('"')) or (
            arg_value.startswith("'") and arg_value.endswith("'")
        ):
            return arg_value[1:-1]

        # If it starts with $, it's a variable reference
        if arg_value.startswith("$"):
            return arg_value

        # Try to parse as number
        try:
            if "." in arg_value:
                return float(arg_value)
            return int(arg_value)
        except ValueError:
            pass

        # Handle special values
        if arg_value.lower() == "true":
            return True
        if arg_value.lower() == "false":
            return False
        if arg_value.lower() == "none":
            return None

        # Default to returning as is
        return arg_value

    def raw(self) -> str:
        """Return the raw text of the output item.

        Returns:
            The raw text of the output item.
        """
        return self.text

    def compact(self) -> str:
        """Return a compact string representation of the extracted metadata.

        This method creates a comma-separated string summarizing the structured
        metadata found within the raw text. If no metadata was found, it returns
        the original raw text.

        Example:
            If text contains `Step["A"]` and `Var["x"]=1`, returns "Step[A], Var[x]=1".
            If text is "Just some text", returns "Just some text".

        Returns:
            A compact string representation of the extracted metadata, or the raw text.
        """
        parts = []

        # Add steps
        for step in self.steps:
            parts.append(f"Step[{step}]")

        # Add variables
        for name, value in self.vars:
            parts.append(f"Var[{name}]={value}")

        # Add triggers
        for trigger in self.triggers:
            parts.append(f"Trigger[{trigger}]")

        # Add tool calls
        for tool_call in self.tool_calls:
            parts.append(self._format_tool_call(tool_call))

        # If no metadata, return the raw text
        if not parts:
            return self.text

        return ", ".join(parts)

    def _format_tool_call(self, tool_call: Dict[str, Any]) -> str:
        """Format a tool call as a string.

        This method formats a tool call dictionary as a string representation,
        including the function name and its arguments.

        Args:
            tool_call: The tool call dictionary to format.

        Returns:
            A string representation of the tool call.
        """
        function_name = tool_call["function_name"]
        args = tool_call["args"]
        kwargs = tool_call["kwargs"]

        # Format the call
        call_str = f"{function_name}("

        # Add positional args
        args_str = ", ".join(str(arg) for arg in args)
        call_str += args_str

        # Add keyword args
        if kwargs:
            if args:
                call_str += ", "
            kwargs_str = ", ".join(f"{k}={v}" for k, v in kwargs.items())
            call_str += kwargs_str
        call_str += ")"

        return call_str

    def __repr__(self) -> str:
        """Return a string representation of the output item.

        Returns:
            A string representation of the output item.
        """
        return f"OutputItem({self.text})"


# Note: StringTrace no longer inherits from OutputItem
class StringTrace:
    """Represents a simple string message produced during execution (e.g., a log or debug trace).

    Attributes:
        message (str): The content of the trace message.
        metadata (Dict[str, Any]): Optional dictionary for additional context.
    """

    def __init__(self, message: str, metadata: Optional[Dict[str, Any]] = None):
        """Initialize a string trace.

        Args:
            message: The message content of the trace.
            metadata: Optional dictionary for additional metadata.
        """
        self.message: str = message
        self.metadata: Dict[str, Any] = metadata or {}
        # No longer setting self.text

    def __repr__(self) -> str:
        """Return the message content as the string representation.

        Returns:
            The trace message string.
        """
        return self.message

    def to_trace(self) -> str:
        """Return the trace message string.

        Returns:
            The trace message string.
        """
        return self.message


# Note: MessageReceived no longer inherits from OutputItem
class MessageReceived:
    """Represents a message received from an agent or user during interaction.

    Attributes:
        message (str): The content of the received message.
        from_agent (Any): Identifier for the sender (agent name, user ID, etc.). Defaults to "System".
        metadata (Dict[str, Any]): Optional dictionary for additional context.
    """

    def __init__(
        self, message: str, from_agent: any, metadata: Optional[Dict[str, Any]] = None
    ):
        """Initialize a received message.

        Args:
            message: The content of the received message.
            from_agent: The sender identifier. Use None for system messages.
            metadata: Optional dictionary for additional metadata.
        """
        self.message: str = message
        # Use "System" if from_agent is None or evaluates to False (e.g., empty string)
        self.from_agent: Any = from_agent or "System"
        self.metadata: Dict[str, Any] = metadata or {}
        # No longer setting self.text

    def __repr__(self) -> str:
        """Return a string representation indicating the sender and message.

        Example: "AgentX said: Hello there!"
                 "System said: Playbook started."

        Returns:
            A string representation of the message received.
        """
        return f"{self.from_agent} said: {self.message}"

    def to_trace(self) -> str:
        """Return a trace representation (sender and message).

        Returns:
            A string representation suitable for tracing/logging.
        """
        return self.__repr__()

    def raw(self) -> str:
        """Return the raw message content without sender information.

        Returns:
            The raw text content of the message.
        """
        return self.message

    def compact(self) -> str:
        """Return a compact representation (sender and message).

        Returns:
            A compact string representation, same as `to_trace()`.
        """
        return self.to_trace()

    def to_session_context(self) -> str:
        """Return a representation suitable for including in session context.

        Returns:
            A string representation for session context, same as `to_trace()`.
        """
        return self.__repr__()
