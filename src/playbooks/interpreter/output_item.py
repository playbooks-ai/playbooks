"""Output item module for the interpreter.

This module contains the OutputItem class, which represents a single item in the
interpreter output and provides methods for parsing and formatting output items.
"""

import ast
import re
from typing import Any, Dict, List, Optional, Tuple


class OutputItem:
    """Represents a single item of raw text output from the interpreter.

    The OutputItem class is responsible for parsing raw text output potentially
    containing structured metadata markers (like Steps, Vars, Triggers, Tool Calls,
    CallStack) generated by the interpreter's LLM. It extracts this metadata
    if present.

    If the text does not contain known metadata markers, the attributes like
    `steps`, `vars`, etc., will remain empty.

    Attributes:
        text (str): The raw text of the output item.
        steps (List[str]): List of step identifiers extracted (e.g., `Step["step_id"]`).
        vars (List[Tuple[str, str]]): List of variable assignments extracted (e.g., `Var["name"] = value`).
        triggers (List[str]): List of trigger identifiers extracted (e.g., `Trigger["trigger_id"]`).
        tool_calls (List[Dict[str, Any]]): List of tool calls extracted (e.g., `ToolName(arg1, kwarg='val')`).
        call_stack (List[str]): List of call stack identifiers extracted (e.g., `CallStack["id1", "id2"]`).
    """

    def __init__(self, text: str):
        """Initialize an output item by parsing the raw text.

        Args:
            text: The raw text of the output item, potentially containing metadata.
        """
        self.text: str = text.strip()
        self.steps: List[str] = []
        self.vars: List[Tuple[str, str]] = []
        self.triggers: List[str] = []
        self.tool_calls: List[Dict[str, Any]] = []
        self.call_stack: List[str] = []

        # Parse the text to extract metadata if present
        self._parse_metadata()

    def _parse_metadata(self) -> None:
        """Parse the raw text to extract structured metadata markers.

        This method uses regular expressions to find and extract steps, variables,
        triggers, tool calls, and call stack information embedded within the text.
        The extracted metadata is stored in the corresponding instance attributes.

        Examples:
            >>> item = OutputItem('`Tool(key1=$var1, key2="value")`')
            >>> item.tool_calls[0]["kwargs"]
            {'key1': '$var1', 'key2': 'value'}

            >>> item = OutputItem('`MyTool(10, "someval", kwarg1="value", kwarg2=$my_var)`')
            >>> item.tool_calls[0]["args"]
            [10, 'someval']
            >>> item.tool_calls[0]["kwargs"]
            {'kwarg1': 'value', 'kwarg2': '$my_var'}
        """
        # Extract Step metadata, e.g., `Step["auth_step"]`
        self.steps = re.findall(r'`Step\["([^"]+)"\]`', self.text)

        # Extract Var metadata, e.g., `Var[$user_email, "test@example.com"]` or `Var[$pin, 1234]`
        # Captures the variable name (with $) and its value, parsing the value as a Python expression
        var_matches = re.findall(r"`Var\[(\$[^,\]]+),\s*([^\]]+)\]`", self.text)
        self.vars = []
        for var_name, var_value_str in var_matches:
            # Parse the value as a Python expression safely
            parsed_value = self._parse_arg_value(var_value_str.strip())
            self.vars.append((var_name, parsed_value))

        # Extract Trigger metadata, e.g., `Trigger["user_auth_failed"]`
        self.triggers = re.findall(r'`Trigger\["([^"]+)"\]`', self.text)

        # Extract CallStack metadata, e.g. `CallStack["Auth:02:QUE", "Playbook10:04.02:QUE"]`
        self.call_stack = re.findall(r'`CallStack\["([^"]+)"\]`', self.text)

        # Extract tool calls (playbook calls) enclosed in backticks.
        # e.g., `MyTool(arg1, arg2, kwarg1="value")` or `Tool(key1=$var1)`
        # or `MyTool(10, "someval", kwarg1="value", kwarg2=$my_var)`
        tool_call_matches = re.findall(r"`([A-Za-z0-9_]+\(.*?\))`", self.text)

        for function_call in tool_call_matches:
            self.tool_calls.append(self._parse_function_call(function_call))

    def _parse_function_call(self, function_call: str) -> Dict[str, Any]:
        """Parse a function call using Python's AST parser.

        This method parses a function call string into a dictionary containing the function name,
        positional arguments, and keyword arguments, handling both literal values and variable
        references (starting with $).

        Args:
            function_call: The complete function call string (e.g., "MyTool(arg1, kwarg='val')").

        Returns:
            A dictionary containing:
                - function_name: The name of the function
                - args: List of positional arguments
                - kwargs: Dictionary of keyword arguments

        Raises:
            ValueError: If the parsed expression is not a function call.
            SyntaxError: If the function call string is not valid Python syntax.
        """
        # Create a valid Python expression by properly handling $variables
        # First, find all $variables and replace them with __substituted__ prefix
        expr = function_call
        # Handle keyword argument names by removing $ prefix
        expr = re.sub(r"\$([a-zA-Z_][a-zA-Z0-9_]*)\s*=", r"\1=", expr)
        # Handle remaining $variables by replacing with __substituted__ prefix
        for match in re.finditer(r"\$[a-zA-Z_][a-zA-Z0-9_]*", expr):
            var = match.group(0)
            expr = expr.replace(var, f"__substituted__{var[1:]}")

        # Parse the expression
        tree = ast.parse(expr, mode="eval")
        if not isinstance(tree.body, ast.Call):
            raise ValueError("Expected a function call")

        # Extract function name
        function_name = tree.body.func.id

        # Extract positional arguments
        args = []
        for arg in tree.body.args:
            if isinstance(arg, ast.Name) and arg.id.startswith("__substituted__"):
                # Convert back to $variable format
                args.append(f"${arg.id[13:]}")
            elif isinstance(arg, ast.Constant):
                args.append(arg.value)
            else:
                args.append(ast.literal_eval(ast.unparse(arg)))

        # Extract keyword arguments
        kwargs = {}
        for keyword in tree.body.keywords:
            if isinstance(keyword.value, ast.Name) and keyword.value.id.startswith(
                "__substituted__"
            ):
                # Convert back to $variable format
                kwargs[keyword.arg] = f"${keyword.value.id[13:]}"
            elif isinstance(keyword.value, ast.Constant):
                kwargs[keyword.arg] = keyword.value.value
            else:
                kwargs[keyword.arg] = ast.literal_eval(ast.unparse(keyword.value))

        return {
            "function_name": function_name,
            "args": args,
            "kwargs": kwargs,
        }

    def _parse_arg_value(self, arg_value: str) -> Any:
        """Parse an argument value to the appropriate type.

        This method converts string representations of values to their appropriate Python types,
        handling strings, numbers, booleans, None, and variable references.

        Args:
            arg_value: The string representation of the argument value.

        Returns:
            The parsed value with the appropriate type.
        """
        # If it starts with $, it's a variable reference
        if arg_value.startswith("$"):
            return arg_value

        # Try to parse as a Python literal using ast.literal_eval
        try:
            return ast.literal_eval(arg_value)
        except (ValueError, SyntaxError):
            # If literal_eval fails, return as is
            return arg_value

    def raw(self) -> str:
        """Return the raw text of the output item.

        Returns:
            The raw text of the output item.
        """
        return self.text

    def compact(self) -> str:
        """Return a compact string representation of the extracted metadata.

        This method creates a comma-separated string summarizing the structured
        metadata found within the raw text. If no metadata was found, it returns
        the original raw text.

        Example:
            If text contains `Step["A"]` and `Var["x"]=1`, returns "Step[A], Var[x]=1".
            If text is "Just some text", returns "Just some text".

        Returns:
            A compact string representation of the extracted metadata, or the raw text.
        """
        parts = []

        # Add steps
        for step in self.steps:
            parts.append(f"Step[{step}]")

        # Add variables
        for name, value in self.vars:
            parts.append(f"Var[{name}, {value}]")

        # Add triggers
        for trigger in self.triggers:
            parts.append(f"Trigger[{trigger}]")

        # Add tool calls
        for tool_call in self.tool_calls:
            parts.append(self._format_tool_call(tool_call))

        # If no metadata, return the raw text
        if not parts:
            return self.text

        return ", ".join(parts)

    def _format_tool_call(self, tool_call: Dict[str, Any]) -> str:
        """Format a tool call as a string.

        This method formats a tool call dictionary as a string representation,
        including the function name and its arguments.

        Args:
            tool_call: The tool call dictionary to format.

        Returns:
            A string representation of the tool call.
        """
        function_name = tool_call["function_name"]
        args = tool_call["args"]
        kwargs = tool_call["kwargs"]

        # Format the call
        call_str = f"{function_name}("

        # Add positional args
        args_str = ", ".join(str(arg) for arg in args)
        call_str += args_str

        # Add keyword args
        if kwargs:
            if args:
                call_str += ", "
            kwargs_str = ", ".join(f"{k}={v}" for k, v in kwargs.items())
            call_str += kwargs_str
        call_str += ")"

        return call_str

    def __repr__(self) -> str:
        """Return a string representation of the output item.

        Returns:
            A string representation of the output item.
        """
        return f"OutputItem({self.text})"


# Note: StringTrace no longer inherits from OutputItem
class StringTrace:
    """Represents a simple string message produced during execution (e.g., a log or debug trace).

    Attributes:
        message (str): The content of the trace message.
        metadata (Dict[str, Any]): Optional dictionary for additional context.
    """

    def __init__(self, message: str, metadata: Optional[Dict[str, Any]] = None):
        """Initialize a string trace.

        Args:
            message: The message content of the trace.
            metadata: Optional dictionary for additional metadata.
        """
        self.message: str = message
        self.metadata: Dict[str, Any] = metadata or {}
        # No longer setting self.text

    def __repr__(self) -> str:
        """Return the message content as the string representation.

        Returns:
            The trace message string.
        """
        return self.message

    def to_trace(self) -> str:
        """Return the trace message string.

        Returns:
            The trace message string.
        """
        return self.message


# Note: MessageReceived no longer inherits from OutputItem
class MessageReceived:
    """Represents a message received from an agent or user during interaction.

    Attributes:
        message (str): The content of the received message.
        from_agent (Any): Identifier for the sender (agent name, user ID, etc.). Defaults to "System".
        metadata (Dict[str, Any]): Optional dictionary for additional context.
    """

    def __init__(
        self, message: str, from_agent: any, metadata: Optional[Dict[str, Any]] = None
    ):
        """Initialize a received message.

        Args:
            message: The content of the received message.
            from_agent: The sender identifier. Use None for system messages.
            metadata: Optional dictionary for additional metadata.
        """
        self.message: str = message
        # Use "System" if from_agent is None or evaluates to False (e.g., empty string)
        self.from_agent: Any = from_agent or "System"
        self.metadata: Dict[str, Any] = metadata or {}
        # No longer setting self.text

    def __repr__(self) -> str:
        """Return a string representation indicating the sender and message.

        Example: "AgentX said: Hello there!"
                 "System said: Playbook started."

        Returns:
            A string representation of the message received.
        """
        return f"{self.from_agent} said: {self.message}"

    def to_trace(self) -> str:
        """Return a trace representation (sender and message).

        Returns:
            A string representation suitable for tracing/logging.
        """
        return self.__repr__()

    def raw(self) -> str:
        """Return the raw message content without sender information.

        Returns:
            The raw text content of the message.
        """
        return self.message

    def compact(self) -> str:
        """Return a compact representation (sender and message).

        Returns:
            A compact string representation, same as `to_trace()`.
        """
        return self.to_trace()

    def to_session_context(self) -> str:
        """Return a representation suitable for including in session context.

        Returns:
            A string representation for session context, same as `to_trace()`.
        """
        return self.__repr__()
