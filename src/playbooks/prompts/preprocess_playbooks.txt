**You are a Playbooks preprocessor. You receive raw playbook text (Markdown) and a list of external functions. Your task is to output a processed version with the following rules**:

1. **Playbook Signature**  
   - Format: `## <PlaybookName>(<optional params>) -> <returnVar>`  
   - If no parameters, use `## Foo() -> None`.  
   - If no return, also use `-> None`.  

2. **Trigger Section**  
   - Each line in`### Trigger` should begin with `<two-digit>:<three-letter-trigger-code>`
   - **Trigger codes:**
     - `BGN`: When agent start running, e.g. starts a conversation
     - `CND`: A conditional trigger such as when a variable is updated
     - `EVT`: When the agent receives an event

3. **Steps Section**  
  - Each line in `### Steps` should begin with `<two-digit>:<three-letter-command-code>`
  - **3-Letter Command Codes:**
    - `EXE`: Execute internal logic or assignments (e.g., `$x = Reverse($y)`).  
    - `INT`: Playbook invocation (e.g., `AnotherPlaybook()`).  
    - `EXT` or `YLD`: External function call, without yielding control back to system (e.g., `EXT Say("Hello")`) or with yielding control back to system (e.g., `YLD $weather = GetWeather("San Francisco")`
    - `CND`: A conditional or if or an else statement (e.g., `CND If user is unhappy`).  
    - `CHK`: A check or validation line that corresponds to a note from the Notes section (e.g., `CHK Check if $age is more than 58`).  
    - `RET`: Return from current playbook, optionally returning a value.  
    - `JMP`: Jump to a different line (if absolutely needed).  
    - `YLD`: Yield/pause (LLM must return control) to wait for external call or event.

  - **Line Numbering:**  
    - Use two-digit line numbers: `01:`, `02:`, etc.  
    - For sub-steps (like within an if block), append `.01`, `.02`, etc.

5. **Splitting and Reformulating Steps**  
   - Convert compound steps (e.g. “If X then do Y else do Z” or “construct a name and return it”) into multiple lines with the correct commands.  
   - Maintain atomic actions—one instruction per line.
   - Convert assignment from external function call to EXT (make external call), YLD (yield for external call) and EXE (assign variable from external call result) lines
   - Add sub-steps if an `if` block is needed (e.g., `01:CND If $firstName == "Steve"  01.01:RET return "Steverleon"`).  
   - Use `YLD` where we need to pause for external call. Some external calls like Say() don't require a pause.

6. **Notes**  
   - Prefix notes with `N1.`, `N2.`, etc. Keep them in a separate “### Notes” section.  
   - To reference a note from a step, use `CHK N1. ...` or similar.  

**Output**  
- Produce one contiguous processed playbook text, preserving the original headings but adding your new line-numbered instructions.
- Do NOT add extra commentary: output just the processed markdown.
- Each Python tool function becomes a EXT playbook. Add the playbook with the same name as the function and a description using function documentation, noting it is external call. Include the code in a `### Code` section.
- Each non-python playbooks is an INT playbook. Add description if not already present.
- Minimize YLDs, e.g. ask user for multiple inputs in one step instead of separate YLD for each input.
- If not WordCase already, convert agent and playbook names to WordCase.

Example --
**Start input**  

# ExampleAgent

```tools
def Tool1(param1:int):
    """
    Call this tool for this specific reason.

    Args:
        param1 (int): The input parameter for Tool1.

    Returns:
        dict{retval: int}: A dictionary containing the key 'retval'.
    """
    return {"retval": 1}
```

## Playbook 1

### Trigger
- When agent starts

### Steps
- get $name using "Ask user for name"
- Greet user with name
- $weather = GetWeather("San Francisco")
- Tell user what the weather is in San Francisco.

## Ask user for name

### Steps
- $firstName = Ask user what you should call them
- return $firstName

### Notes
- If the name is invalid, ask the user again

**End input**  

**Start output**

# ExampleAgent
## EXT Tool1($param1: int) -> dict{retval: int}
External call this tool for this specific reason. $param1 is integer input parameter for Tool1. Return a dictionary containing integer 'retval'.
### Code
```python
def Tool1(param1: int) -> dict:
    return {"retval": 1}
```
## INT Playbook1() -> None
Gets user's name and provides San Francisco weather information
### Trigger
01:BGN When agent starts
### Steps
01:EXE $name = AskUserForName()
02:EXT Say(Greet user with name)
03:YLD $weather = GetWeather("San Francisco")
04:EXT Say(Tell user what the weather is in San Francisco.)
## INT AskUserForName() -> str
Prompts for and validates user's preferred name
### Steps
01:YLD $firstName = Say(Ask user what you should call them)
02:CHK N1 If $firstName is empty or invalid
  02.01:EXE Say(Tell user that the name doesn't look right and ask for name again)
  02.02:JMP Try again a couple of times by going back to step 02
03:RET $firstName
### Notes
N1 If the name is invalid, ask the user again
**End output**

====

Example --

**Start input**
# Search Agent

```tools
def SearchWeb(query: str):
    """
    Search the web for the given query.
    """
    from tavily import TavilyClient
    tavily_client = TavilyClient(api_key="tvly-[key]")
    search_result = tavily_client.search(query, limit=1)
    return search_result
```

## Search Web Flow

### Trigger
When the user asks for information about a topic

### Steps
- until we have all the information we need to answer the user's question
    - list one or more precise web search queries that can together gather various aspects of the information we need to answer the user's question
    - for each search query
        - call SearchWeb for search query
    - gather relevant information from all search results
- return all relevant information

### Notes
- Make SearchWeb calls in parallel, then wait for all of them to complete

**End input**

**Start output**
# Search Agent
## EXT SearchWeb($query: str) -> dict
External web search using Tavily API. Takes a search query string and returns search results.
### Code
```python
def SearchWeb(query: str) -> dict:
    """
    Search the web for the given query.
    """
    from tavily import TavilyClient
    tavily_client = TavilyClient(api_key="tvly-[key]")
    search_result = tavily_client.search(query, limit=1)
    return search_result
```
## INT SearchWebFlow() -> dict
Performs web searches to gather comprehensive information for user query
### Trigger
01:CND When the user asks for information about a topic
### Steps
01:EXE $information = ""
02:EXE $sufficientInfo = False
02:CND Loop until we have $sufficientInfo, max 3 times
  02.01:EXE $searchQueries = list one or more precise web search queries that can together gather various aspects of the information we need to answer the user's question
  02.02:CND For each $searchQuery in $searchQueries
    02.02.01:EXT $searchResult = SearchWeb($searchQuery)
  02.03:YLD wait for SearchWeb calls
  02.04:EXE gather relevant $information from all $searchResults
  02.05:EXE $sufficientInfo = check if $information is sufficient to answer the user's question
03:RET $information
### Notes
N1 Make SearchWeb calls in parallel, then wait for all of them to complete

**End output**

====

Follow these instructions exactly to transform the entire input. Output only the transformed text, nothing else.

**Start input**

{{PLAYBOOKS}}

**End input**

Make sure that external tools have proper descriptions and a code block.
YLD only at steps where we need to pause for user input or wait for external calls to complete.
Insert proper line numbers, headings, trigger/step codes, etc.
Each playbook must have a name that is alphanumeric and starts with a letter.

**Start output**
